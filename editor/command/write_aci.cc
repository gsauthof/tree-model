// Copyright 2016, Georg Sauthoff <mail@georg.so>

/* {{{ LGPLv3

    This file is part of tree-model.

    tree-model is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    tree-model is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with tree-model.  If not, see <http://www.gnu.org/licenses/>.

}}} */

#include "write_aci.hh"

#include <QAbstractItemModel>
#include <QMimeData>
#include <QByteArray>
#include <QEventLoop>
#include <QTimer>

#include <xfsx/xml_writer_arguments.hh>
#include <xfsx/tap/traverser.hh>
#include <xfsx/byte.hh>

#include <editor/traverser/qmi_proxy.hh>
#include <editor/traverser/check_cancel.hh>

#include <xxxml/util.hh>
#include <xfsx/traverser/lxml.hh>

#include <tree_model/util.hh>
#include <tree_model/item_adaptor.hh>
#include <tree_model/xml.hh>

using namespace std;

namespace editor {
  namespace command {

    void Write_ACI::set_delay(unsigned d)
    {
      delay_ = d;
    }
    void Write_ACI::set_epoche(unsigned e)
    {
      epoche_ = e;
    }
    void Write_ACI::set_cancel_function(std::function<bool()> f)
    {
      cancel_fn_ = f;
    }

    void Write_ACI::set_model(QAbstractItemModel *model)
    {
      model_ = model;
    }
    void Write_ACI::set_tree_model(const tree_model::Base *tree_model)
    {
      tree_model_ = tree_model;
    }
    void Write_ACI::set_file_type(const File_Type &ft)
    {
      file_type_ = ft;
    }

    void Write_ACI::write()
    {
      if (!model_)
        return;
      if (!tree_model_)
        return;

      xfsx::xml::Pretty_Writer_Arguments pargs(file_type_.asn_filenames());

#if 0
      tree_model::DF_QMI_Traverser t(model_->index(0, 0));
      editor::traverser::QMI_Proxy p(pargs.name_translator);
#else
      // Optimizaton:
      // get the XML document (from the tree_model::Base) and
      // traverse that
      // advantage: temporary QVariant/string objects can be
      // avoided
      auto tree_model = dynamic_cast<const tree_model::XML*>(tree_model_);
      const xxxml::doc::Ptr &doc = tree_model->doc();
      xxxml::util::DF_Traverser t(doc);
      xfsx::traverser::LXML_Proxy p(pargs.name_translator);
#endif

      xfsx::tap::traverser::Audit_Control_Info aci;
      editor::traverser::Check_Cancel check_cancel;
      check_cancel.epoche_ = epoche_;
      check_cancel.was_canceled_fn_ = cancel_fn_;

      // for testing purposes
      if (delay_) {
        QEventLoop e;
        QTimer::singleShot(delay_, [&e]{ e.quit(); });
        e.exec();
      }

      aci(p, t, check_cancel);
      // -> may throw: (const editor::traverser::Cancel_Exception &e)
      // iff cancel_fn_ returns true

      xfsx::byte::writer::Memory m;
      aci.comment = "Generated by libxfsx";
      aci.print(m);

      emit begin_transaction_requested(tr("Write ACI"));
      auto old = tree_model::util::find_child(model_->index(0, 0),
          "AuditControlInfo");
      if (old.isValid())
        model_->removeRow(old.row(), old.parent());

      QMimeData md;
      md.setData("text/xml", QByteArray(m.begin(), m.end() - m.begin()));
      model_->dropMimeData(&md, Qt::CopyAction, -1, -1, model_->index(0, 0));

      emit commit_requested();
      emit msg_produced(tr("Computed and wrote Audit Control Info"));
    }

  } // namespace command
} // namespace editor
