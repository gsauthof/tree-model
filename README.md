Example of a hierarchical tree model in [Qt][qt].

The example uses Qt 5 and [libxml2][libxml2] (via
[libxxxml][libxxxml]) to work on XML trees. It implements an
abstract tree model and provides an adaptor to
QAbstractItemModel. In addition to that, a generic Undo/Redo
class interfaces with QAbstractItemModel.

An example GUI XML editor is included to demonstrate the model in
action.

Each class has several unittest test cases. Besides catching
errors and regressions, they can also be consulted as examples
how the different APIs are intended to be used.

2016, Georg Sauthoff <mail@georg.so>


## Challenges

### Build system

[CMake][cmake] is used - cmake usually makes it easy to build C++
projects, but the CMake Qt support is relatively new, is not
extensively documented and there are some tutorials available
that use deprecated cmake Qt commands.

There are also pitfalls, e.g. if you use namespaces and want to
generate Qt moc files for classes with the same name that are
located in different namespaces. As of 2015, this yields
collisions if you use `CMAKE_AUTOMOC ON`.

Similar issues occur with `.ui` files, only worse - even if you
omit `CMAKE_AUTOUIC`, all files are still generated in the top
level build directory.

### Unittesting

Structuring the code into models, controllers, views; thus
separating GUI parts as much as possible from non-GUI
functionality also simplifies how to test much of the code. But
still, view related parts need to be tested as well - and this is
a challenge - because you basically have to automate a GUI.

The example demonstrates with a dialog test-suite
(`ut_select_open`) how to use [QTest][qtest]. In that test-suite,
QTest is used to execute the tests, check assertions, inject key
press and mouse click events and to spy on signals.

It is perhaps not entirely obvious how to use general purpose
unittest libraries for testing Qt GUI elements. The test-suite
`ut_gui` demonstrates it - it uses [Catch][catch] for execution,
assertion etc. and QTest only for event injection and signal
spying.

### Subclassing QAbstractItemModel

Using QAbstractItemModel for hierarchical models assumes that
following operations run fast: 1) determine the number of
children of a node 2) Random access the k-th child 3) determine
the rank of a node (i.e. the position inside the siblings list).

It seems that these operations are often not implemented in
existing hierarchical data structures, because they are not
needed for other use cases and implementing them has a cost.  In
this example, the existing hierarchical data structure is a
DOM-like XML node tree generated by libxml2. It does not
efficiently support these operations. Thus, inspired by
QAbstractItemModel, the abstract model class `tree_model::Base`
is created that does not require these operations. The class
`tree_model::Item_Adaptor` is derived from `QAbstractItemModel`
and maps its calls to `tree_model::Base` ones. It does so via
caching and using ranked lists, a data structure where random
access are efficient.

### Rank Operations

As part of the tree_model::Item_Adaptor a data structure is
needed that allows for efficient rank operations (e.g. accessing
the k-th element or determing the rank of an element). Just using
a combination of lookup tables and a list is not sufficient,
because operations like removal and insertion should be
effiecient as well. A ranked list is a skip list variant (cf.
`list/ranked_list.hh` for details), i.e.  it is a probabilistic
data structure.

### Undo/Redo

Qt does not provide an API for implementing undo/redo operations
on QAbstractItemModel models. In general there are two approaches
to undo/redo: 1) make your data-structure immutable (like in
functional programming, thus you get old versions of it 'for
free' 2) create an edit operation object that contains enough
information to reverse it,for each change, and put those objects
in a list.

The first approach is only an option if you design your tree data
structure from scratch. In case the undo should be limited (to
safe space) the removal of old elements might be challenging.

The second approach arguably is simpler but does not really scale
if many different kind of edit operations need to be covered. But
this is not the case for an QAbstractItemModel model, where you
need to cover 'just' set-data, insert and remove.
  
Thus, the tree-model library implements the 2nd approach for
undo/redo in the class `tree_model::Recorder`. An Recorder
instance is associated to a QAbstractItemModel instance via
being connected to all its 'interesting' edit related signals.
It records edit operations via storing edit operation objects
into double-ended queue. Transactions and limited undo are
supported, where unlimited undo/redo is the default.

### Clipboard Support

Qt has a class for interacting with the system's clipboard in a
portable fashion. When dealing with `QAbstractItemModel`s it is
natural to also use the drag-and-drop related methods
`dropMimeData()` and `mimeData()` to paste and copy the clipboard
data. The adaptor model thus also implements them and translates
them into equivalent calls of the `tree_model::Base` model.

Using XML as the serialization format of the clipboard has the
advantage that it is human readable and can be easiliy changed
with a normal text editor. When multiple elements should be
copied or inserted one has to decide how to map that to XML since
an XML document may only have one root. One possibility is to
create an artificial root element that is part of the mime data.
The editor example implements a variation. The serialized XML is just a
concatenation of serialized subtrees, thus, not necessarily a
valid XML document as such.  But, on deserialization the document
is implicitly wrapped with an artificical root element such that
an off-the-shelf XML parser can be used (after insert that root
is discarded).

With the Qt clipboard API one has to decide which clipboards to
support exactly. For example under X11, there is the primary
selection buffer and a normal clipboard. Also, a clipboard may
contain a document in several versions (with different mime
types). The editor example thus exports a copied selection multiple
times: into the selection buffer, into the normal clipboard as
normal text and with mime-type 'text/xml'. The normal text copy
is done because this is what normal text editor request; such
that the 'text/xml' version is ignored. The mime-type 'text/xml'
is what is expected by the editor - also for drag-and-drop
operations. The X11 selection copy is done for convenience, e.g.
to easily paste something into a terminal window.

### Drag and Drop

After central methods of the `QAbstractItemModel` are
implemented in the `tree_model::Base` (like removal, mime data
export/import) it isn't much work to get drag and drop
functionality enabled in the view and the model.

See also

- `Item_Adaptor::mimeTypes()`
- `Item_Adaptor::mimeData()`
- `Item_Adaptor::dropMimeData()`
- `Item_Adaptor::canDropMimeData()`
- `Item_Adaptor::supportedDropActions()`
- `Item_Adaptor::flags()`

and

- `XML::mime_types()`
- `XML::mime_data()`
- `XML::drop_mime_data()`
- `XML::can_drop_mime_data()`
- `XML::supported_drop_actions()`
- `XML::flags()`

and the `Tree_View` constructor for details what is necessary to
implement and customize drag-and-drop (supporting copy and move
actions) for hierachical models.

### UI

Creating dialog and widgets, thus, distributing the widgets and
configuring layout policies can get challenging.  Thus, a
graphical editor like the UI component of Qt-Creator is a help.
Challenges still occur, e.g. if you want to use namespaces. It is
possible, but the support in Qt Creator is limited (as of 2015).

## Architecture

Qt provides some classes to implement data models and views. This
is similar to the [MVC][mvc] architecture - but without the
seperation of the controller. Thus, the Qt documentation
consequently calls its variation just [model/view][mv]
architecture and argues that combining the view and the
controller would simplify the framework. This might be the case -
but it also doesn't help with simiplifying the structure of the
application.

Thus, the challenge in writing a graphical Qt application is to
decide where to put the non-view/non-model logic, i.e. the
controller logic. The code that fills and changes the model,
executes actions in response to a clicked button etc.

Scatter such code around some view parts doesn't seem to be a
good idea. Especially since the result isn't testable, hard to
maintain and not reusable.

The graphical example application separates view code from
controller code as much as possible. Dialog and widget classes
don't contain any controlling code. Instead, they expose signal
and slots that are connected by a controller class to command
objects. The controller and the command classes are separated
into a non-GUI and GUI part, where the GUI part extends the
non-GUI one. For example, the open command reads a file and
creates the model - the GUI part extends that command and adds a
graphical progress dialog to it.


## Structure

Repository Overview:

    tree_model/          Tree model, QAbstractItemModel adaptor,
                         undo/redo recorder etc.
       operation/        Operations supported by the undo/redo
                         recorder
    list/                Ranked list datastructure used by the
                         tree model adaptor
    libxxxml/            Thin libxml2 C++ wrapper, git submodule
    editor/              example GUI application using the tree
                         model, i.e. an XML editor.
                         Directory contains widgets, dialogs
                         and application specific classes (e.g.
                         argument parsing).
        command/         Commands that can be used without a GUI
        gui_command/     Commands that need a GUI, e.g. because
                         they display dialogs.
        controller.*     Owns the command objects and the model.
                         Connects them together.
        gui_controller.* Graphical part of the controller
        main.cc          Defintion of the editor's main()
                         function.
    test/                Unittests, subdirectories mirror the
                         repository structure.
        main.cc          Setup of [Catch][catch] based non-GUI
                         testsuite.
        gui_main.cc      Setup of [Catch][catch] based GUI
                         testsuite.
        test.cc          Setup of [QTest][qtest] based GUI
                         testsuite.

Tree-Model classes:

    Base               Tree-model base class
                       no random access methods
    Index              References a node inside Base
    XML                Implements the Base tree model for a libxml2 DOM-like
                       tree data structure
    Item_Adaptor       Translates between an associated Base
                       tree model and a QAbstractItemModel
    Deep_Model_Index   Converts a QModelIndex into a persistent
                       reference
    Recorder           Records edit operations of an associated
                       QAbstractItemModel and provide undo/redo.


## License

[LGPLv3+][lgpl]



[lgpl]: https://www.gnu.org/licenses/lgpl-3.0.en.html
[qt]: http://www.qt.io/
[cmake]: https://en.wikipedia.org/wiki/CMake
[qtest]: http://doc.qt.io/qt-5/qtest-overview.html
[catch]: https://github.com/philsquared/Catch
[libxml2]: https://en.wikipedia.org/wiki/Libxml2
[libxxxml]: https://github.com/gsauthof/libxxxml
[mvc]: https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller
[mv]: http://doc.qt.io/qt-5/model-view-programming.html#the-model-view-architecture
